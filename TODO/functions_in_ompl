# ----------------------------------------------------------------
# # # # # utils_ompl.py # # # # # 
# ----------------------------------------------------------------
pairwise_link_collision: 这个函数检查两个物体之间的两个链接是否有碰撞。它使用 pybullet 的 getClosestPoints 函数来计算两个物体之间的最近点。
pairwise_collision: 这个函数检查两个物体是否有碰撞。如果两个物体是元组，则它会检查所有链接对是否有碰撞，否则它会检查整个物体是否有碰撞。
expand_links: 这个函数将物体和链接扩展为元组。
any_link_pair_collision: 这个函数检查两个物体之间的所有链接对是否有碰撞。
body_collision: 这个函数检查两个整个物体之间是否有碰撞。
get_self_link_pairs: 这个函数获取一个物体的所有活动和固定链接对。
get_moving_links: 这个函数获取一个物体的所有移动链接。
get_moving_pairs: 这个函数获取一个物体的所有移动链接对。

辅助函数:
get_joint_info: 获取关节信息。
child_link_from_joint: 从关节获取子链接。
get_num_joints: 获取物体的关节数。
get_joints: 获取物体的所有关节。
get_links: 获取物体的所有链接。
get_all_links: 获取物体的所有链接，包括基础链接。
get_link_parent: 获取链接的父链接。
get_all_link_parents: 获取物体的所有链接的父链接。
get_all_link_children: 获取物体的所有链接的子链接。
get_link_children: 获取链接的子链接。
get_link_ancestors: 获取链接的所有祖先链接。
get_joint_ancestors: 获取关节的所有祖先关节。
get_link_descendants: 获取链接的所有后代链接。
get_link_subtree: 获取链接的所有子树链接。
are_links_adjacent: 检查两个链接是否相邻。

全局变量:
BASE_LINK: 表示基础链接的常量。
MAX_DISTANCE: 表示最大距离的常量。


# ----------------------------------------------------------------
# # # # # pb_ompl.py # # # # # 
# ----------------------------------------------------------------
这段代码是一个使用OMPL库和pybullet库的机器人运动规划代码。它包括了机器人类、状态空间类和运动规划类，并包括了运动规划、碰撞检测、执行计划等功能

全局变量: 
定义了两个全局变量INTERPOLATE_NUM和DEFAULT_PLANNING_TIME。

主要类:
PbOMPLRobot: 这是一个机器人类，用于与PbOMPL类一起使用。此类包含了机器人的一些基本信息，例如机器人的id、关节索引、关节范围等。它还有一些方法，如get_joint_bounds用于获取关节范围，set_state用于设置机器人的状态，reset用于重置机器人的状态等。
PbStateSpace: 这是一个状态空间类，继承自ompl.base.RealVectorStateSpace。这个类用于分配状态采样器和设置自定义状态采样器。
PbOMPL: 这是主要的运动规划类。这个类负责设置状态空间、状态有效性检查器、碰撞检测、规划器、起始和目标状态、运动规划、执行计划等。

函数:
plan_start_goal: 这个方法是用于从给定的起始状态到目标状态的运动规划。它设置了起始和目标状态，然后尝试在允许的时间内解决问题。如果找到解决方案，它将对解决方案路径进行插值，然后返回解决方案路径。否则，它将返回No solution found。
plan: 这个方法是用于从当前机器人状态到目标状态的运动规划。
execute: 这个方法是用于执行计划的路径。它将遍历路径中的每个状态，并设置机器人的状态。如果dynamics为True，它将使用动力学模拟，否则它将简单地重置机器人的状态。
set_state_sampler: 这个方法是用于设置自定义状态采样器。
state_to_list: 这个方法是用于将状态转换为列表。

运动规划:
代码使用Open Motion Planning Library (OMPL)来进行运动规划。OMPL是一个用于运动规划的开源库，它包括了多种运动规划算法，如PRM、RRT、RRTConnect、RRTstar、EST、FMT、BITstar等。这个代码默认使用RRT算法，但是可以通过set_planner方法来设置不同的规划器。

碰撞检测:
代码使用pybullet库来进行碰撞检测。pybullet是一个物理模拟库，它可以用于机器人动力学模拟、碰撞检测、逆动力学等。

注意事项:
代码中有一些TODO和WARN标记，这意味着代码可能还没有完全完成，可能需要进一步的修改和测试。
代码中的PbOMPLRobot类默认假设所有的关节都是动力的，应该被计划。如果这不是期望的行为，则需要编写自己的继承类，覆盖相应的功能。
代码中的PbOMPL类的execute方法中的dynamics参数，如果设置为False，代码将简单地重置机器人的状态，而不进行任何动力学模拟。因为路径是无碰撞的，所以这是可以接受的。

# ----------------------------------------------------------------
# # # # # utils_PbOMPL.py # # # # # 
# ----------------------------------------------------------------
这是一个Python类，名称是PbOMPL，主要用于机器人运动规划。它使用OMPL(Open Motion Planning Library)库作为底层来进行实际的运动规划。类的主要属性和方法如下：
该类提供了机器人运动规划的完整工作流程，包括设置障碍物，规划抓取和移动，以及执行规划的路径。

属性：
pb_client: 与pybullet服务器通信的客户端。
arm_id: 机器人的ID。
joint_idx: 用于规划的关节索引。
tcp_link: 工具中心点(TCP)的链接索引。
obstacles: 运动规划中要考虑的障碍物列表。
planner: 使用的运动规划算法的名称。
threshold: 仅用于重新规划的阈值。
arm: 机器人的arm对象。
tcp_link: 工具中心点(TCP)的链接。
max_attempts: 重新规划的最大尝试次数。
pb_ompl_interface: OMPL接口对象。
target: 用于操纵任务的目标对象的ID。
target_pos: 目标对象的位置。

方法：
set_planner: 设置OMPL的规划器。
set_target: 设置操纵任务的目标。
set_target_pos: 设置目标的位置。
set_obstacles: 设置OMPL的障碍物。
add_obstacles: 向障碍物列表中添加障碍物。
remove_obstacles: 从障碍物列表中移除障碍物。
store_obstacles: 在OMPL接口中存储障碍物。
check_obstacles: 检查场景中的障碍物并将它们打印到控制台。
get_scene_items: 获取场景中所有物体的ID。
add_scene_obstacles: 向场景中添加障碍物。
execute: 使用OMPL接口执行给定的路径并处理错误。
compute_distance: 计算末端执行器和物体之间的距离。
plan_grasp: 计划从起点到终点的抓取。
move_end_effector_to_goal_position: 在OMPL规划的路径中将末端执行器移动到目标位置。
reach_object: 计划从起点到终点的对象，并将其附加到机器人上。